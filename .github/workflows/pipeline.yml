# =============================================================================
# Academia Platform - Unified CI/CD Pipeline
# =============================================================================
#
# Pipeline Flow:
#   feature/* → Dev1 (auto) → PR → develop → Dev2 (auto) →
#   release/* → Testing (auto) → main → Staging (auto) →
#   tag v* → Production (manual approval)
#
# Environments: dev1, dev2, testing, staging, production
# AWS Services: Lambda, API Gateway, S3, Route53, Aurora Serverless, CloudFront, ACM
# =============================================================================

name: CI/CD Pipeline

on:
  push:
    branches:
      - "feature/**"
      - develop
      - "release/**"
      - main
    tags:
      - "v*"
  pull_request:
    branches: [develop, main]

concurrency:
  group: pipeline-${{ github.ref }}
  cancel-in-progress: ${{ !startsWith(github.ref, 'refs/tags/') }}

env:
  NODE_VERSION: "20"
  AWS_REGION: us-east-1

# =============================================================================
# JOBS
# =============================================================================
jobs:
  # ===========================================================================
  # Stage 1: Build & Test (All branches)
  # ===========================================================================

  build-backend:
    name: Build Backend
    runs-on: ubuntu-latest
    outputs:
      build-successful: ${{ steps.build.outcome == 'success' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: backend
        run: npm ci

      - name: Generate Prisma Client
        working-directory: backend
        run: npx prisma generate

      - name: Lint
        working-directory: backend
        run: npm run lint

      - name: Type check
        working-directory: backend
        run: npx tsc --noEmit

      - name: Run unit tests
        id: test
        working-directory: backend
        run: npm test -- --coverage --passWithNoTests
        env:
          NODE_ENV: test

      - name: Build
        id: build
        working-directory: backend
        run: npm run build

      - name: Package Lambda
        working-directory: backend
        run: |
          mkdir -p lambda-package
          cp -r dist lambda-package/
          cp -r node_modules lambda-package/
          cp package.json lambda-package/
          cp -r prisma lambda-package/
          cd lambda-package && zip -r ../backend-lambda.zip .

      - name: Upload backend artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-lambda
          path: backend/backend-lambda.zip
          retention-days: 7

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        if: github.event_name == 'pull_request'
        with:
          files: backend/coverage/lcov.info
          flags: backend

  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    outputs:
      build-successful: ${{ steps.build.outcome == 'success' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Lint
        working-directory: frontend
        run: npm run lint --if-present

      - name: Type check
        working-directory: frontend
        run: npx tsc --noEmit --skipLibCheck

      - name: Run tests
        working-directory: frontend
        run: npm test -- --coverage --passWithNoTests --watchAll=false
        env:
          CI: true

      - name: Build
        id: build
        working-directory: frontend
        run: npm run build
        env:
          CI: true

      - name: Upload frontend artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/build
          retention-days: 7

  validate-infrastructure:
    name: Validate Infrastructure
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: infrastructure/cdk/package-lock.json

      - name: Install CDK dependencies
        working-directory: infrastructure/cdk
        run: npm ci

      - name: Synthesize CDK (validate templates)
        working-directory: infrastructure/cdk
        run: npx cdk synth --all --context environment=dev1
        env:
          CDK_DEFAULT_ACCOUNT: "000000000000"
          AWS_REGION: ${{ env.AWS_REGION }}

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          severity: "CRITICAL,HIGH"
          exit-code: "0"

      - name: npm audit backend
        working-directory: backend
        run: npm audit --audit-level=high || true

      - name: npm audit frontend
        working-directory: frontend
        run: npm audit --audit-level=high || true

  # ===========================================================================
  # Stage 2: Determine Environment
  # ===========================================================================

  determine-environment:
    name: Determine Target Environment
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend, validate-infrastructure]
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should-deploy: ${{ steps.set-env.outputs.should-deploy }}
      run-e2e: ${{ steps.set-env.outputs.run-e2e }}
      run-performance: ${{ steps.set-env.outputs.run-performance }}
      requires-approval: ${{ steps.set-env.outputs.requires-approval }}

    steps:
      - name: Set environment based on ref
        id: set-env
        run: |
          REF="${{ github.ref }}"
          EVENT="${{ github.event_name }}"

          echo "Processing ref: $REF, event: $EVENT"

          if [[ "$EVENT" == "pull_request" ]]; then
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "run-e2e=true" >> $GITHUB_OUTPUT
            echo "run-performance=false" >> $GITHUB_OUTPUT
            echo "requires-approval=false" >> $GITHUB_OUTPUT
          elif [[ "$REF" == refs/heads/feature/* ]]; then
            echo "environment=dev1" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "run-e2e=false" >> $GITHUB_OUTPUT
            echo "run-performance=false" >> $GITHUB_OUTPUT
            echo "requires-approval=false" >> $GITHUB_OUTPUT
          elif [[ "$REF" == "refs/heads/develop" ]]; then
            echo "environment=dev2" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "run-e2e=true" >> $GITHUB_OUTPUT
            echo "run-performance=false" >> $GITHUB_OUTPUT
            echo "requires-approval=false" >> $GITHUB_OUTPUT
          elif [[ "$REF" == refs/heads/release/* ]]; then
            echo "environment=testing" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "run-e2e=true" >> $GITHUB_OUTPUT
            echo "run-performance=true" >> $GITHUB_OUTPUT
            echo "requires-approval=false" >> $GITHUB_OUTPUT
          elif [[ "$REF" == "refs/heads/main" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "run-e2e=true" >> $GITHUB_OUTPUT
            echo "run-performance=true" >> $GITHUB_OUTPUT
            echo "requires-approval=false" >> $GITHUB_OUTPUT
          elif [[ "$REF" == refs/tags/v* ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "run-e2e=true" >> $GITHUB_OUTPUT
            echo "run-performance=true" >> $GITHUB_OUTPUT
            echo "requires-approval=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "run-e2e=false" >> $GITHUB_OUTPUT
            echo "run-performance=false" >> $GITHUB_OUTPUT
            echo "requires-approval=false" >> $GITHUB_OUTPUT
          fi

  # ===========================================================================
  # Stage 3: E2E Tests (for PRs and higher environments)
  # ===========================================================================

  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend, determine-environment]
    if: needs.determine-environment.outputs.run-e2e == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Download backend artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-lambda
          path: backend

      - name: Download frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: frontend/build

      - name: Unzip backend
        working-directory: backend
        run: |
          unzip -o backend-lambda.zip -d lambda-extracted
          cp -r lambda-extracted/* .

      - name: Install E2E dependencies
        working-directory: e2e
        run: |
          npm ci
          npx playwright install --with-deps chromium

      - name: Setup test database
        working-directory: backend
        run: |
          npx prisma generate
          npx prisma db push --skip-generate
        env:
          DATABASE_URL: file:./test.db

      - name: Start backend server
        working-directory: backend
        run: node dist/main.js &
        env:
          NODE_ENV: test
          DATABASE_URL: file:./test.db
          JWT_SECRET: test-secret-for-ci
          PORT: 3333

      - name: Serve frontend
        run: npx serve -s frontend/build -l 3000 &

      - name: Wait for services
        run: |
          npm install -g wait-on
          wait-on http://localhost:3333/health http://localhost:3000 --timeout 60000

      - name: Run E2E tests
        working-directory: e2e
        run: npm test -- --project=chromium
        env:
          BASE_URL: http://localhost:3000
          API_URL: http://localhost:3333

      - name: Upload E2E report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-report
          path: e2e/playwright-report
          retention-days: 7

  # ===========================================================================
  # Stage 4: Deploy to Environment
  # ===========================================================================

  deploy:
    name: Deploy to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, e2e-tests, security-scan]
    if: |
      always() && 
      needs.determine-environment.outputs.should-deploy == 'true' &&
      (needs.e2e-tests.result == 'success' || needs.e2e-tests.result == 'skipped')
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
      url: ${{ steps.deploy-output.outputs.frontend-url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: infrastructure/cdk/package-lock.json

      - name: Download backend artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-lambda
          path: artifacts

      - name: Download frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: frontend/build

      - name: Install CDK dependencies
        working-directory: infrastructure/cdk
        run: npm ci

      - name: Deploy CDK Stack
        id: cdk-deploy
        working-directory: infrastructure/cdk
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          echo "Deploying to environment: $ENV"

          # Capitalize first letter for stack name
          ENV_CAPITALIZED="$(echo ${ENV:0:1} | tr '[:lower:]' '[:upper:]')${ENV:1}"

          # First ensure shared database is deployed (only creates once)
          echo "Ensuring shared database stack is deployed..."
          npx cdk deploy AcademiaSharedDatabase \
            --require-approval never \
            --outputs-file shared-db-outputs.json || true

          # Deploy environment-specific stacks
          echo "Deploying backend and frontend for $ENV..."
          npx cdk deploy "AcademiaBackend-${ENV_CAPITALIZED}" "AcademiaFrontend-${ENV_CAPITALIZED}" \
            --context environment=$ENV \
            --require-approval never \
            --outputs-file cdk-outputs.json

          # Extract outputs
          cat cdk-outputs.json
        env:
          HOSTED_ZONE_ID: ${{ secrets.HOSTED_ZONE_ID }}

      - name: Update Lambda code
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          FUNCTION_NAME="academia-backend-${ENV}"

          aws lambda update-function-code \
            --function-name $FUNCTION_NAME \
            --zip-file fileb://artifacts/backend-lambda.zip \
            --publish

      - name: Deploy frontend to S3
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          BUCKET_NAME="academia-frontend-${ENV}-${{ secrets.AWS_ACCOUNT_ID }}"

          aws s3 sync frontend/build s3://$BUCKET_NAME --delete

      - name: Invalidate CloudFront
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"

          # Get distribution ID from outputs or by tag
          DIST_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Academia Frontend - ${ENV}'].Id" \
            --output text)

          if [ -n "$DIST_ID" ]; then
            aws cloudfront create-invalidation \
              --distribution-id $DIST_ID \
              --paths "/*"
          fi

      - name: Run database migrations
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          FUNCTION_NAME="academia-backend-${ENV}"
          DB_NAME="academia_${ENV}"

          echo "Running migrations for database: $DB_NAME"

          # Invoke Lambda with migration command
          # The Lambda will use the environment-specific database
          aws lambda invoke \
            --function-name $FUNCTION_NAME \
            --payload "{\"command\": \"migrate\", \"database\": \"$DB_NAME\"}" \
            --cli-binary-format raw-in-base64-out \
            response.json || true

          cat response.json

      - name: Output deployment URLs
        id: deploy-output
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"

          case $ENV in
            dev1) SUBDOMAIN="dev1.academia" ;;
            dev2) SUBDOMAIN="dev2.academia" ;;
            testing) SUBDOMAIN="test.academia" ;;
            staging) SUBDOMAIN="staging.academia" ;;
            production) SUBDOMAIN="academia" ;;
          esac

          echo "frontend-url=https://${SUBDOMAIN}.icitysystems.org" >> $GITHUB_OUTPUT
          echo "api-url=https://api.${SUBDOMAIN}.icitysystems.org" >> $GITHUB_OUTPUT

      - name: Post deployment summary
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${ENV}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend URL:** ${{ steps.deploy-output.outputs.frontend-url }}" >> $GITHUB_STEP_SUMMARY
          echo "**API URL:** ${{ steps.deploy-output.outputs.api-url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Stage 5: Performance Tests (Testing, Staging, Production)
  # ===========================================================================

  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy]
    if: needs.determine-environment.outputs.run-performance == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install k6
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: Run load tests
        working-directory: e2e/performance
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"

          case $ENV in
            testing) BASE_URL="https://test.academia.icitysystems.org" ;;
            staging) BASE_URL="https://staging.academia.icitysystems.org" ;;
            production) BASE_URL="https://academia.icitysystems.org" ;;
          esac

          k6 run --env BASE_URL=$BASE_URL load-test.js

      - name: Upload performance results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: performance-results
          path: e2e/performance/results
          retention-days: 30

  # ===========================================================================
  # Stage 6: Smoke Tests (Post-deployment verification)
  # ===========================================================================

  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Run smoke tests
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"

          case $ENV in
            dev1) BASE_URL="https://dev1.academia.icitysystems.org" ;;
            dev2) BASE_URL="https://dev2.academia.icitysystems.org" ;;
            testing) BASE_URL="https://test.academia.icitysystems.org" ;;
            staging) BASE_URL="https://staging.academia.icitysystems.org" ;;
            production) BASE_URL="https://academia.icitysystems.org" ;;
          esac

          API_URL="https://api.${BASE_URL#https://}"

          echo "Testing frontend: $BASE_URL"
          curl -f -s -o /dev/null -w "%{http_code}" "$BASE_URL" | grep -q "200\|301\|302"

          echo "Testing API health: $API_URL/health"
          curl -f -s "$API_URL/health" || curl -f -s "${API_URL}health" || echo "Health check endpoint may not be configured"

          echo "Smoke tests passed!"

  # ===========================================================================
  # Stage 7: Production Approval Gate
  # ===========================================================================

  production-approval:
    name: Production Deployment Approval
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy, performance-tests, smoke-tests]
    if: needs.determine-environment.outputs.requires-approval == 'true'
    environment:
      name: production-approval

    steps:
      - name: Approval received
        run: |
          echo "Production deployment approved by: ${{ github.actor }}"
          echo "Approval timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

  # ===========================================================================
  # Stage 8: Notify on Completion
  # ===========================================================================

  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy, smoke-tests]
    if: always()

    steps:
      - name: Notify on success
        if: needs.deploy.result == 'success'
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          echo "✅ Deployment to $ENV successful!"
          # Add Slack/Teams notification here if needed

      - name: Notify on failure
        if: needs.deploy.result == 'failure'
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          echo "❌ Deployment to $ENV failed!"
          # Add Slack/Teams notification here if needed

  # ===========================================================================
  # Rollback Job (Manual trigger via workflow_dispatch)
  # ===========================================================================

  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'rollback'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rollback Lambda to previous version
        run: |
          ENV="${{ github.event.inputs.environment }}"
          FUNCTION_NAME="academia-backend-${ENV}"

          # Get the previous version
          VERSIONS=$(aws lambda list-versions-by-function \
            --function-name $FUNCTION_NAME \
            --query 'Versions[*].Version' \
            --output text)

          PREV_VERSION=$(echo $VERSIONS | tr ' ' '\n' | grep -v '\$LATEST' | sort -rn | sed -n '2p')

          if [ -n "$PREV_VERSION" ]; then
            echo "Rolling back to version: $PREV_VERSION"
            
            # Update alias or publish new version pointing to previous code
            aws lambda update-alias \
              --function-name $FUNCTION_NAME \
              --name live \
              --function-version $PREV_VERSION || \
            aws lambda publish-version \
              --function-name $FUNCTION_NAME \
              --description "Rollback to version $PREV_VERSION"
          else
            echo "No previous version found to rollback to"
            exit 1
          fi

      - name: Post rollback summary
        run: |
          echo "## Rollback Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
