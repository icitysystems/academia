import { Injectable, Logger } from "@nestjs/common";
import { PrismaService } from "../prisma.service";
import * as ExcelJS from "exceljs";
import * as PDFDocument from "pdfkit";

export interface ReportData {
	title: string;
	headers: string[];
	rows: any[][];
	metadata?: Record<string, string>;
}

export type ExportFormat = "pdf" | "excel" | "csv";

@Injectable()
export class ReportExportService {
	private readonly logger = new Logger(ReportExportService.name);

	constructor(private prisma: PrismaService) {}

	/**
	 * Export report to the specified format
	 */
	async exportReport(data: ReportData, format: ExportFormat): Promise<Buffer> {
		switch (format) {
			case "pdf":
				return this.exportToPDF(data);
			case "excel":
				return this.exportToExcel(data);
			case "csv":
				return this.exportToCSV(data);
			default:
				throw new Error(`Unsupported export format: ${format}`);
		}
	}

	/**
	 * Export lesson tracking report
	 */
	async exportLessonTrackingReport(
		teacherId: string,
		options: {
			classSubjectId?: string;
			startDate?: Date;
			endDate?: Date;
			format: ExportFormat;
		},
	): Promise<Buffer> {
		const whereClause: any = {
			classSubject: { teacherId },
		};

		if (options.classSubjectId) {
			whereClause.classSubjectId = options.classSubjectId;
		}
		if (options.startDate) {
			whereClause.date = { gte: options.startDate };
		}
		if (options.endDate) {
			whereClause.date = { ...whereClause.date, lte: options.endDate };
		}

		const lessons = await this.prisma.lesson.findMany({
			where: whereClause,
			include: {
				classSubject: {
					include: {
						class: true,
						subject: true,
					},
				},
			},
			orderBy: { date: "asc" },
		});

		const reportData: ReportData = {
			title: "Lesson Tracking Report",
			headers: [
				"Date",
				"Class",
				"Subject",
				"Topic",
				"Duration (mins)",
				"Status",
				"Attendance",
				"Notes",
			],
			rows: lessons.map((lesson) => {
				// Parse extended data from notes JSON
				let topicTitle = "N/A";
				let notesText = lesson.notes || "";
				try {
					if (lesson.notes) {
						const parsed = JSON.parse(lesson.notes);
						topicTitle = parsed.extendedData?.topicTitle || "N/A";
						notesText = parsed.text || "";
					}
				} catch {
					notesText = lesson.notes || "";
				}
				return [
					lesson.date.toLocaleDateString(),
					lesson.classSubject.class.name,
					lesson.classSubject.subject.name,
					topicTitle,
					lesson.duration || 0,
					lesson.status,
					lesson.attendance || "N/A",
					notesText,
				];
			}),
			metadata: {
				"Generated By": teacherId,
				"Generated At": new Date().toISOString(),
				"Total Lessons": lessons.length.toString(),
			},
		};

		return this.exportReport(reportData, options.format);
	}

	/**
	 * Export class summary report
	 */
	async exportClassSummaryReport(
		templateId: string,
		teacherId: string,
		format: ExportFormat,
	): Promise<Buffer> {
		const template = await this.prisma.template.findUnique({
			where: { id: templateId },
		});

		if (!template || template.createdById !== teacherId) {
			throw new Error("Template not found");
		}

		const pdfOutputs = await this.prisma.pDFOutput.findMany({
			where: {
				sheet: { templateId },
			},
			include: {
				sheet: true,
			},
			orderBy: { createdAt: "desc" },
		});

		const reportData: ReportData = {
			title: `Class Summary: ${template.name}`,
			headers: [
				"Student ID",
				"Total Score",
				"Max Score",
				"Percentage",
				"Grade",
				"Graded At",
			],
			rows: pdfOutputs.map((output) => {
				const percentage =
					output.maxScore > 0
						? Math.round((output.totalScore / output.maxScore) * 100)
						: 0;
				const grade = this.calculateGrade(percentage);

				return [
					output.sheet.studentId || "N/A",
					output.totalScore,
					output.maxScore,
					`${percentage}%`,
					grade,
					output.createdAt.toLocaleDateString(),
				];
			}),
			metadata: {
				"Template": template.name,
				"Total Students": pdfOutputs.length.toString(),
				"Average Score": this.calculateAverage(pdfOutputs).toString(),
			},
		};

		return this.exportReport(reportData, format);
	}

	/**
	 * Export student progress report
	 */
	async exportStudentProgressReport(
		studentId: string,
		format: ExportFormat,
	): Promise<Buffer> {
		const student = await this.prisma.user.findUnique({
			where: { id: studentId },
			select: { name: true, email: true },
		});

		if (!student) {
			throw new Error("Student not found");
		}

		const enrollments = await this.prisma.enrollment.findMany({
			where: { studentId },
			include: {
				course: true,
				lessonProgress: {
					include: { lesson: true },
				},
			},
		});

		const submissions = await this.prisma.assignmentSubmission.findMany({
			where: { studentId, score: { not: null } },
			include: {
				assignment: {
					include: {
						lesson: {
							include: {
								module: {
									include: { course: true },
								},
							},
						},
					},
				},
			},
			orderBy: { gradedAt: "desc" },
		});

		const reportData: ReportData = {
			title: `Student Progress Report: ${student.name}`,
			headers: [
				"Course",
				"Assignment",
				"Score",
				"Max Score",
				"Percentage",
				"Grade",
				"Graded At",
			],
			rows: submissions.map((sub) => {
				const percentage =
					sub.maxScore && sub.maxScore > 0
						? Math.round(((sub.score || 0) / sub.maxScore) * 100)
						: 0;
				return [
					sub.assignment.lesson?.module?.course?.title || "N/A",
					sub.assignment.title,
					sub.score || 0,
					sub.maxScore || 0,
					`${percentage}%`,
					this.calculateGrade(percentage),
					sub.gradedAt?.toLocaleDateString() || "N/A",
				];
			}),
			metadata: {
				"Student": student.name || "",
				"Email": student.email,
				"Total Enrollments": enrollments.length.toString(),
				"Total Submissions": submissions.length.toString(),
			},
		};

		return this.exportReport(reportData, format);
	}

	private async exportToPDF(data: ReportData): Promise<Buffer> {
		return new Promise((resolve, reject) => {
			const chunks: Buffer[] = [];
			const doc = new PDFDocument({ margin: 50 });

			doc.on("data", (chunk) => chunks.push(chunk));
			doc.on("end", () => resolve(Buffer.concat(chunks)));
			doc.on("error", reject);

			// Title
			doc.fontSize(20).text(data.title, { align: "center" });
			doc.moveDown();

			// Metadata
			if (data.metadata) {
				doc.fontSize(10).fillColor("#666");
				Object.entries(data.metadata).forEach(([key, value]) => {
					doc.text(`${key}: ${value}`);
				});
				doc.moveDown();
				doc.fillColor("#000");
			}

			// Table header
			doc.fontSize(10).font("Helvetica-Bold");
			const startX = 50;
			const colWidth = (doc.page.width - 100) / data.headers.length;
			let y = doc.y;

			data.headers.forEach((header, i) => {
				doc.text(header, startX + i * colWidth, y, {
					width: colWidth,
					align: "left",
				});
			});

			doc.moveDown();
			doc.font("Helvetica");

			// Table rows
			data.rows.forEach((row) => {
				y = doc.y;

				// Check for page break
				if (y > doc.page.height - 100) {
					doc.addPage();
					y = 50;
				}

				row.forEach((cell, i) => {
					const cellText =
						cell !== null && cell !== undefined ? String(cell) : "";
					doc.text(cellText.substring(0, 30), startX + i * colWidth, y, {
						width: colWidth,
						align: "left",
					});
				});

				doc.moveDown(0.5);
			});

			// Footer
			doc
				.fontSize(8)
				.text(
					`Generated on ${new Date().toLocaleString()}`,
					50,
					doc.page.height - 50,
					{ align: "center" },
				);

			doc.end();
		});
	}

	private async exportToExcel(data: ReportData): Promise<Buffer> {
		const workbook = new ExcelJS.Workbook();
		const worksheet = workbook.addWorksheet("Report");

		// Title
		worksheet.mergeCells("A1:H1");
		const titleCell = worksheet.getCell("A1");
		titleCell.value = data.title;
		titleCell.font = { size: 16, bold: true };
		titleCell.alignment = { horizontal: "center" };

		// Metadata
		let rowIndex = 3;
		if (data.metadata) {
			Object.entries(data.metadata).forEach(([key, value]) => {
				worksheet.getCell(`A${rowIndex}`).value = key;
				worksheet.getCell(`B${rowIndex}`).value = value;
				rowIndex++;
			});
			rowIndex++;
		}

		// Headers
		const headerRow = worksheet.getRow(rowIndex);
		data.headers.forEach((header, i) => {
			const cell = headerRow.getCell(i + 1);
			cell.value = header;
			cell.font = { bold: true };
			cell.fill = {
				type: "pattern",
				pattern: "solid",
				fgColor: { argb: "FFE0E0E0" },
			};
		});
		rowIndex++;

		// Data rows
		data.rows.forEach((row) => {
			const dataRow = worksheet.getRow(rowIndex);
			row.forEach((cell, i) => {
				dataRow.getCell(i + 1).value = cell;
			});
			rowIndex++;
		});

		// Auto-fit columns
		worksheet.columns.forEach((column) => {
			column.width = 15;
		});

		const buffer = await workbook.xlsx.writeBuffer();
		return Buffer.from(buffer);
	}

	private exportToCSV(data: ReportData): Promise<Buffer> {
		const lines: string[] = [];

		// Headers
		lines.push(data.headers.map((h) => `"${h}"`).join(","));

		// Rows
		data.rows.forEach((row) => {
			lines.push(
				row
					.map((cell) => {
						const cellStr =
							cell !== null && cell !== undefined ? String(cell) : "";
						return `"${cellStr.replace(/"/g, '""')}"`;
					})
					.join(","),
			);
		});

		return Promise.resolve(Buffer.from(lines.join("\n"), "utf-8"));
	}

	private calculateGrade(percentage: number): string {
		if (percentage >= 90) return "A";
		if (percentage >= 80) return "B";
		if (percentage >= 70) return "C";
		if (percentage >= 60) return "D";
		return "F";
	}

	private calculateAverage(outputs: any[]): number {
		if (outputs.length === 0) return 0;
		const sum = outputs.reduce((acc, o) => {
			const pct = o.maxScore > 0 ? (o.totalScore / o.maxScore) * 100 : 0;
			return acc + pct;
		}, 0);
		return Math.round(sum / outputs.length);
	}
}
